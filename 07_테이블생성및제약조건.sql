-- DDL(CRATE TABLE) 및 제약조건

-- DDL(DATA DEFINITION LANGUAGE) : 데이터 정의 언어

-- 테이블 만들기
-- [표현식] :
-- CREATE TABLE 테이블명(컬럼명 자료형(크기), 컬럼명 자료형(크기)....);
CREATE TABLE MEMBER(
  MEMBER_ID VARCHAR2(20),
  MEMBER_PWD VARCHAR2(20),
  MEMBER_NAME VARCHAR2(20)
);

SELECT
       M.*
  FROM MEMBER M;
  
-- 컬럼에 주석 달기
-- [표현식]
-- COMMENT ON COLUMN 테이블명.컬럼명 IS '주석내용';
COMMENT ON COLUMN MEMBER.MEMBER_ID IS '회원아이디';
COMMENT ON COLUMN MEMBER.MEMBER_PWD IS '비밀번호';
COMMENT ON COLUMN MEMBER.MEMBER_NAME IS '회원이름';

SELECT 
       UT.*
  FROM USER_TABLES UT;

SELECT
       UTC.*
  FROM USER_TAB_COLUMNS UTC
 WHERE UTC.TABLE_NAME = 'MEMBER';

DESC MEMBER;

-- 제약조건
-- 테이블 작성 시 각 컬럼에 대해 값 기록에 대한 제약조건을 설정할 수 있다.
-- 데이터 무결성 보장을 목적으로 한다.
-- 입력/수정하는 데이터에 문제가 없는지 자동으로 검사하는 목적
-- PRIMARY KEY, NOT NULL, UNIQUE, CHECK, FOREIGN KEY

SELECT
       UC.*
  FROM USER_CONSTRAINTS UC;

SELECT 
       UCC.*
  FROM USER_CONS_COLUMNS UCC;

-- NOT NULL : 해당 컬럼에 반드시 값이 기록되어야 하는 경우 사용
--            삽입/수정 시 NULL값을 허용하지 않도록 컬럼 레벨에서 제한
CREATE TABLE USER_NOCONS(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

--ALTER USER C##EMPLOYEE QUOTA 1024M ON USERS;

INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, NULL
, NULL
, NULL
, NULL
, '010-1234-5678'
, 'hong123@greedy.com'
);

COMMIT; 
-- CREATE관련된 DDL구문은 실행과 동시에 바로 반영된다.
-- INSERT, UPDATE, DELETE와 같은 DML구문일 경우 자동으로 반영되는것이 아니라서
-- 수행한 결과를 완료를 시킬려면 COMMIT, 마지막 COMMIT시점으로 되돌리려면 ROLLBACK을 적용시켜준다.


CREATE TABLE USER_NOTNULL(
  USER_NO NUMBER NOT NULL, -- 컬럼레벨 제약조건 설정
  USER_ID VARCHAR2(20) NOT NULL,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30) NOT NULL,
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_NOTNULL
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, NULL
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

-- UNIQUE 제약조건 : 컴럼에 입력한 값에 대해 중복을 제한하는 제약조건
--                  컬럼레벨에서 설정가능, 테이블 레벨에서도 설정 가능
SELECT 
       UN.*
  FROM USER_NOCONS UN;

INSERT
  INTO USER_NOCONS
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

ROLLBACK;

CREATE TABLE USER_UNIQUE(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE NOT NULL, -- 컬럼레벨에서 제약조건 
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50)
);

INSERT
  INTO USER_UNIQUE
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

SELECT
       UCC.TABLE_NAME
     , UCC.COLUMN_NAME
     , UC.CONSTRAINT_TYPE
  FROM USER_CONSTRAINTS UC
     , USER_CONS_COLUMNS UCC
 WHERE UC.CONSTRAINT_NAME = UCC.CONSTRAINT_NAME
   AND UCC.CONSTRAINT_NAME = 'SYS_C007383';
   
   
CREATE TABLE USER_UNIQUE2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) NOT NULL, 
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_ID) -- 테이블 레벨에서 제약조건 설정
);   
   
INSERT
  INTO USER_UNIQUE2
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);  

-- 두개의 컬럼을 묶어서 하나의 UNIQUE 제약조건 설정
CREATE TABLE USER_UNIQUE3(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30),
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(3),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50),
  UNIQUE(USER_NO, USER_ID)
); 

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);     

INSERT
  INTO USER_UNIQUE3
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  2
, 'user02'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);        
   
-- CHECK 제약 조건 : 컬럼에 기록되는 값에 조건을 설정할 수 있다.
-- CHECK(컬럼 명 비교연산자 비교값)
-- 주의 : 비교값은 리터럴만 사용할 수 있다. 변하는 값이나 함수 사용을 못한다.

CREATE TABLE USER_CHECK(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10) CHECK(GENDER IN('남','여')),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50)
);   
   
INSERT
  INTO USER_CHECK
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남'
, '010-1234-5678'
, 'hong123@greedy.com'
);   
INSERT
  INTO USER_CHECK
(
  USER_NO
, USER_ID
, USER_PWD
, USER_NAME
, GENDER
, PHONE
, EMAIL
)
VALUES
(
  1
, 'user01'
, 'pass01'
, '홍길동'
, '남자'
, '010-1234-5678'
, 'hong123@greedy.com'
);   

CREATE TABLE TEST_CHECK(
    TEST_NUMBER NUMBER,
    CONSTRAINT CK_TEST_NUMBER CHECK(TEST_NUMBER > 0)
);

INSERT 
   INTO TEST_CHECK
(
   TEST_NUMBER
)
VALUES
(
   10
);

INSERT 
   INTO TEST_CHECK
(
   TEST_NUMBER
)
VALUES
(
   -10
);   
   
CREATE TABLE TBL_CHECK(
    C_NAME VARCHAR(2),
    C_PRICE NUMBER,
    C_LEVEL CHAR(1),
    C_DATE DATE,
    CONSTRAINT CK_C_PRICE CHECK(C_PRICE >= 1 AND C_PRICE <= 99999),
    CONSTRAINT CK_C_LEVEL CHECK(C_LEVEL = 'A' OR C_LEVEL = 'B' OR C_LEVEL = 'C'),
    CONSTRAINT CK_C_DATE CHECK(C_DATE >= SYSDATE)
);  
   
-- 회원 가입 테이블 생성(USER_TEST)   
/*
    컬럼명 : USER_NO(회원번호)
            USER_ID(회원아이디) -- 중복금지 NULL값 허용 안함
            USER_PWD(회원비밀번호)NULL값 허용 안함
            PNO(주민번호) 중복금지 NULL값 허용안함
            GENDER(성별) 남 또는 여로 입력
            PHONE(연락처)
            ADDRESS(주소)
            STATUS(탈퇴여부) NOT NULL Y OR N
*/

CREATE TABLE USER_TEST(
    USER_NO NUMBER,
    USER_ID VARCHAR(20) CONSTRAINT NN_USER_ID NOT NULL,
    USER_PWD VARCHAR(20) CONSTRAINT NN_USER_PWD NOT NULL,
    PNO VARCHAR2(20) CONSTRAINT NN_PNO NOT NULL,
    GENDER VARCHAR2(3),
    PHONE VARCHAR2(20),
    ADDRESS VARCHAR2(255),
    STATUS VARCHAR2(3) CONSTRAINT NN_STATUS NOT NULL,
    CONSTRAINT UK_USER_ID UNIQUE(USER_ID),
    CONSTRAINT UK_PNO UNIQUE(PNO),
    CONSTRAINT CK_GENDER CHECK(GENDER IN('남', '여')),
    CONSTRAINT CK_STATUS CHECK(STATUS IN('Y', 'N'))
);  

-- 코멘트
COMMENT ON COLUMN USER_TEST.USER_NO IS '회원번호';
COMMENT ON COLUMN USER_TEST.USER_ID IS '회원아이디';
COMMENT ON COLUMN USER_TEST.USER_PWD IS '회원비밀번호';
COMMENT ON COLUMN USER_TEST.PNO IS '주민번호';
COMMENT ON COLUMN USER_TEST.GENDER IS '성별';
COMMENT ON COLUMN USER_TEST.PHONE IS '연락처';
COMMENT ON COLUMN USER_TEST.ADDRESS IS '주소';
COMMENT ON COLUMN USER_TEST.STATUS IS '탈퇴여부';
   
INSERT 
  INTO USER_TEST
(
  USER_NO, USER_ID, USER_PWD, PNO, GENDER, PHONE, ADDRESS, STATUS
)
VALUES
(
  1, 'USER01', 'PASS01', '881122-1234567' ,'남', '010-1234-5678','서울시 강남구 역삼동', 'N'
);

-- PRIMARY KEY(기본키) 제약조건 PK
-- 테이블에서 한 행의 정보를 찾기 위해 사용할 컬럼을 의미한다.
-- 테이블에 대한 식별자 역할을 한다.
-- NOT NULL + UNIQUE 제약조건의 의미 
-- 한 테이블당 한 개만 설정 
-- 컬럼 레벨, 테이블 레벨 둘 다 설정 가능하다.
-- 한 개 컬럼에 설정할 수도 있고, 여러개의 컬럼을 묶어서 설정할 수 있다.

CREATE TABLE USER_PRIMARYKEY(
  USER_NO NUMBER CONSTRAINT PK_USER_NO PRIMARY KEY, --컬럼레벨
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50)
);

INSERT
   INTO USER_PRIMARYKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@greedy.com'
);

-- PK는 중복될 수 없음
INSERT
   INTO USER_PRIMARYKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     1, 'user02', 'pass02', '이순신', '남', '010-1111-1111', 'LEE123@greedy.com'
);
-- PK는 NULL일 수 없음
INSERT
   INTO USER_PRIMARYKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     NULL, 'user03', 'pass03', '유관순', '여', '010-2222-2222', 'YU123@greedy.com'
);

--PRIMARYKEY를 두개를 지정할 수 있다.
CREATE TABLE USER_PRIMARYKEY2(
  USER_NO NUMBER,
  USER_ID VARCHAR2(20),
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(255),
  EMAIL VARCHAR2(50),
  CONSTRAINT PK_USER_NO2 PRIMARY KEY(USER_NO, USER_ID)
);

INSERT
   INTO USER_PRIMARYKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     1, 'user01', 'pass01', '홍길동', '남', '010-1234-5678', 'hong123@greedy.com'
);

-- PK 2개가 같지않아서 가능
INSERT
   INTO USER_PRIMARYKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     1, 'user02', 'pass02', '이순신', '남', '010-1111-1111', 'LEE123@greedy.com'
);

--PK 2개가 같지않아서 가능
INSERT
   INTO USER_PRIMARYKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     2, 'user01', 'pass01', '유관순', '여', '010-2222-2222', 'YU123@greedy.com'
);

INSERT
   INTO USER_PRIMARYKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME, GENDER, PHONE, EMAIL
)
VALUES
(
     1, 'user01', 'pass01', '신사임당', '여', '010-3333-3333', 'SIN23@greedy.com'
);

-- FOREIGN KEY(외부키/ 외래키) 제약조건(FK) :
-- 참조(REFERENCES)된 다른 테이블에서 제공하는 값만 사용할 수 있다.
-- 참조 무결성을 위배하지 않게 하기 위해 사용
-- FOREIGN KEY 제약조건에 의해서 테이블간의 관계(RELATIONSHIP)가 형성된다.
-- 제공되는 값 이외에는 NULL을 사용할 수 있다.

-- 컬럼레벨일 경우
-- 컬럼명 자료형(크기) [CONSTRAINT 이름] REFERENCES 참조할테이블명 [(참조할 컬럼)] [삭제롤]

-- 테이블 레벨일 경우
-- [CONSTRAINT 이름] FOREIGN KEY (적용할 컬럼명)REFERENCES 참조할 테이블 명 [(참조할 컬럼)] [삭제롤]

-- 참조할 테이블의 참조할 컬럼명이 생략되면 FRIMARYKEY로 설정된 컬럼이 자동 참조할 컬럼이 된다.
-- 참조될 수 있는 컬럼은 PRIMARY KEY 컬럼과 UNIQUE 지정된 컬러만 외래키로 참조할 수 있다.

CREATE TABLE USER_GRADE(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
  
INSERT
  INTO USER_GRADE
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    10
 , '일반회원'
);
INSERT
  INTO USER_GRADE
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    20
 , '우수회원'
);   
INSERT
  INTO USER_GRADE
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    30
 , '특별회원'
);
COMMIT;

CREATE TABLE USER_FOREIGNKEY(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE (GRADE_CODE)
);
   
INSERT
  INTO USER_FOREIGNKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    1, 'USER01', 'PASS01','홍길동',
    '남','010-1111-1111', 'HONG@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    2, 'USER02', 'PASS02', '이순신',
    '남','010-2222-2222', 'LEE@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    3, 'USER03', 'PASS03', '유관순',
    '여','010-3333-3333', 'YU@GREEDY.COM',30
);

INSERT
  INTO USER_FOREIGNKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    4, 'USER04', 'PASS04', '안중근',
    '남','010-5555-5555', 'AN@GREEDY.COM', NULL
);

-- 실행 시 부모 키가 없음.
INSERT
  INTO USER_FOREIGNKEY
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    5, 'USER05', 'PASS05', '윤봉길',
    '남','010-6665-5555', 'AN@GREEDY.COM', 50
);

COMMIT;

-- 삭제옵션
-- 부모테이블의 테이터 삭제 시 자식 테이블의 데이터를 어떤 식으로 처리할지에 대한 내용을 설정할 수 있다.
-- ON DELECT RESTRICTED로 지정되어있다.
-- FOREIGN KEY로 지정된 컬럼에서 사용되고 있는 값을 경우 제공하는 컬럼의값은 삭제하지 못한다.
DELETE 
   FROM USER_GRADE
  WHERE GRADE_CODE = 10;

-- ON DELETE SET NULL : 부모키를 삭제시 자식키를 NILL로 변경

CREATE TABLE USER_GRADE2(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
  
INSERT
  INTO USER_GRADE2
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    10
 , '일반회원'
);
INSERT
  INTO USER_GRADE2
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    20
 , '우수회원'
);   
INSERT
  INTO USER_GRADE2
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    30
 , '특별회원'
);

CREATE TABLE USER_FOREIGNKEY2(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE2 FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE2 (GRADE_CODE) ON DELETE SET NULL
);
   
INSERT
  INTO USER_FOREIGNKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    1, 'USER01', 'PASS01','홍길동',
    '남','010-1111-1111', 'HONG@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    2, 'USER02', 'PASS02', '이순신',
    '남','010-2222-2222', 'LEE@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    3, 'USER03', 'PASS03', '유관순',
    '여','010-3333-3333', 'YU@GREEDY.COM',30
);
INSERT
  INTO USER_FOREIGNKEY2
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    4, 'USER04', 'PASS04', '안중근',
    '남','010-5555-5555', 'AN@GREEDY.COM', NULL
);

COMMIT;

DELETE 
  FROM USER_GRADE2
 WHERE GRADE_CODE = 10;

-- ON DELETE CASCADE : 부모키 삭제 시 자식키를 가진 행도 삭제
CREATE TABLE USER_GRADE3(
    GRADE_CODE NUMBER PRIMARY KEY,
    GRADE_NAME VARCHAR2(30) NOT NULL
);
  
INSERT
  INTO USER_GRADE3
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    10
 , '일반회원'
);
INSERT
  INTO USER_GRADE3
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    20
 , '우수회원'
);   
INSERT
  INTO USER_GRADE3
(
    GRADE_CODE
  , GRADE_NAME
)
VALUES 
(
    30
 , '특별회원'
);

CREATE TABLE USER_FOREIGNKEY3(
  USER_NO NUMBER PRIMARY KEY,
  USER_ID VARCHAR2(20) UNIQUE,
  USER_PWD VARCHAR2(30) NOT NULL,
  USER_NAME VARCHAR2(30),
  GENDER VARCHAR2(10),
  PHONE VARCHAR2(30),
  EMAIL VARCHAR2(50),
  GRADE_CODE NUMBER,
  CONSTRAINT FK_GRADE_CODE3 FOREIGN KEY (GRADE_CODE) REFERENCES USER_GRADE3 (GRADE_CODE) ON DELETE CASCADE
);
   
INSERT
  INTO USER_FOREIGNKEY3
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    1, 'USER01', 'PASS01','홍길동',
    '남','010-1111-1111', 'HONG@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY3
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    2, 'USER02', 'PASS02', '이순신',
    '남','010-2222-2222', 'LEE@GREEDY.COM',10
);

INSERT
  INTO USER_FOREIGNKEY3
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    3, 'USER03', 'PASS03', '유관순',
    '여','010-3333-3333', 'YU@GREEDY.COM',30
);
INSERT
  INTO USER_FOREIGNKEY3
(
    USER_NO, USER_ID, USER_PWD, USER_NAME,
    GENDER, PHONE, EMAIL, GRADE_CODE
)
VALUES
(
    4, 'USER04', 'PASS04', '안중근',
    '남','010-5555-5555', 'AN@GREEDY.COM', NULL
);
COMMIT;


DELETE 
  FROM USER_GRADE3
 WHERE GRADE_CODE = 10;

--서브 쿼리를 이용한 테이블 생성
CREATE TABLE EMPLOYEE_COPY
AS 
SELECT
       E.*
   FROM EMPLOYEE E;
   
SELECT
       EC.*
   FROM EMPLOYEE_COPY EC;
   
--컬럼명, 데이터 타입, 값이 복사되고 제약조건은 NOT NULL만 복사
CREATE TABLE EMPLOYEE_COPY2
AS 
SELECT
       E.EMP_ID
     , E.EMP_NAME
     , E.SALARY
     , D.DEPT_TITLE
     , J.JOB_NAME
   FROM EMPLOYEE E
   LEFT JOIN DEPARTMENT D ON(E.DEPT_CODE = D.DEPT_ID)
   LEFT JOIN JOB J ON(E.JOB_CODE = J.JOB_CODE);
   
SELECT
       EC.*
   FROM EMPLOYEE_COPY EC;

-- 제약조건 추가
-- ALTER TABLE 테이블명 ADD PRIMARY KEY(컬럼명);
-- ALTER TABLE 테이블명 ADD FOREIGN KEY(컬럼명) REFERENCES 테이블명(컬럼명);
-- ALTER TABLE 테이블명 ADD UNIQUE(컬럼명);
-- ALTER TABLE 테이블명 ADD CHECK(컬럼명 비교연산자 비교값);
-- ALTER TABLE 테이블명 MODIFY 컬럼명 NOT NULL;
ALTER TABLE EMPLOYEE_COPY ADD PRIMARY KEY(EMP_ID);

-- 실습
-- DEPARTMENT 테이블에 기본키 제약조건 추가
ALTER TABLE DEPARTMENT ADD PRIMARY KEY(DEPT_ID);

-- EMPLOYEE 테이블의 DEPT_CODE에 외래키 제약조건 추가
-- 참조 테이블은 DEPARTMENT, 참조컬럼은 DEPARTMENT의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(DEPT_CODE) REFERENCES DEPARTMENT(DEPT_ID);

-- DEPARTMENT 테이블의 LOCATION_ID에 외래키 제약조건 추가
-- 참조 테이블은 LOCATION, 참조 컬럼은 LOCATION의 기본키
ALTER TABLE DEPARTMENT ADD FOREIGN KEY(LOCATION_ID) REFERENCES LOCATION(LOCAL_CODE);

-- EMPLOYEE 테이블의 JOB_CODE에 외래키 제약조건 추가
-- 참조 테이블은 JOB 테이블, 참조 컬럼은 JOB테이블의 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(JOB_CODE) REFERENCES JOB;

-- EMPLOYEE 테이블의 SAL_LEVEL에 외래키 제약조건 추가
-- 참조테이블은 SAL_GRADE테이블, 참조 컬럼은 SAL_GRADE테이블 기본키
ALTER TABLE EMPLOYEE ADD FOREIGN KEY(SAL_LEVEL) REFERENCES SAL_GRADE;

-- EMPLOYEE테이블의 ENT_YN컬럼에 CHECK제약조건 추가('Y','N')
-- 단, 대 소문자를 구분하기 때문에 대문자로 설정
ALTER TABLE EMPLOYEE ADD CHECK(ENT_YN IN('Y', 'N'));

-- EMPLOYEE테이블의 SALARY 컬럼에 CHECK제약조건 추가(양수)
ALTER TABLE EMPLOYEE ADD CHECK(SALARY > 0);

-- EMPLOYEE테이블의 EMP_NO컬럼에 UNIQUE 제약조건 추가
ALTER TABLE EMPLOYEE ADD UNIQUE(EMP_NO);
